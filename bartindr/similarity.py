import numpy as np
import pandas as pd

from sklearn.metrics.pairwise import euclidean_distances, cosine_distances

from data_grabbing import BarData

class SimilarityAnalysis(BarData):
    """
    dataclass for calculating drink distances and returning similar drinks
    """

    def __init__(self, cocktail_df=None, prop_df=None, metric='cosine'):
        """
        Parameters
        ----------
        cocktail_df : untransformed dataset of string ingretient lists
            generaed by data_grabbing.BarData
        prop_df : pandas.DataFrame
            dataframe of preprocessed, proportional data generated by
            data_grabbing.BarData
        """
        self.metric = metric
        self.cocktail_df = cocktail_df
        self.prop_df = prop_df
        super(SimilarityAnalysis, self).__init__()
        if (cocktail_df is None) or (prop_df is None):
            self.gather_data()

        self.X = self.prop_df.values
        self.calculate_similarity()


    def calculate_similarity(self):
        if self.metric == 'cosine':
            self.distance_matrix = pd.DataFrame(cosine_distances(self.X),
                                                columns=self.prop_df.index,
                                                index=self.prop_df.index)
        elif self.metric == 'euclidean':
            self.distance_matrix = pd.DataFrame(euclidean_distances(self.X),
                                                columns=self.prop_df.index,
                                                index=self.prop_df.index)
        else:
            print('assign valid distance metric')


    def print_top_similar(self, n=3, display_proportions=False):
        """
        print top n drinks by descending similarity

        Parameters
        ----------
        n : int > 0
            number of top simililar drinks to display
        display_proportions: bool
            if True, displays as proportional values (limited to quantitative values)
            if False, displays as original recipe (mixed floats and strings)
        """
        #print chosen_drink recipe here
        for i in range(1,n+1):
            sim_i = self.similarity_array.index[i]
            sim_val = self.similarity_array[i]

            print('*'*40)
            print(f'{self.chosen_drink} is {sim_val:.3f} similar to a : {sim_i}')
            print(f'\n{sim_i}\n')
            if display_proportions:
                print(self.prop_df.loc[sim_i, (self.prop_df.loc[sim_i] != 0)])
            else:
                print(self.cocktail_df.loc[sim_i].dropna())


    def choose_random_drink(self):

        return np.random.choice(self.prop_df.index)


    def get_similar_drink(self,
                          chosen_drink=None,
                          print_n_similar=None,
                          display_proportions=False ):
        """
        Use similarity matrix to identify most similar drinks to chosen_drink.
        Optionally prints original recipe

        Parameters
        ----------
        chosen_drink : str or None
            Drink to use as a reference
        print_n_similar : int or None
            Number of similar drinks to print, in descending order
        display_proportions : bool
            if False, prints recipe in original format of mixed string and float values
            if True, prints recipe as proportions (limited to quantifiable metrics)
        """

        if not chosen_drink:
            chosen_drink = choose_random_drink()
            print(f"picking drink at random: {chosen_drink}")
        else:
            self.chosen_drink = chosen_drink

        similarity_array = 1-self.distance_matrix[chosen_drink].sort_values()

        most_similar_drink = similarity_array.index[1]
        similarity = similarity_array[1]

        self.similarity_array = similarity_array
        self.most_similar_drink = most_similar_drink
        self.similarity = similarity
        if print_n_similar:
            print_top_similar(print_n_similar, display_proportions)
